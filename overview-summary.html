<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Exec - OS Process Manager for Erlang VM.
</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<h1>Exec - OS Process Manager for Erlang VM.
</h1>
<p><b>Version:</b> 3a9158f5d6174e7da9fe348c4017b0495a7cd103</p>
<p><b>Authors:</b> Serge Aleynikov (<a href="mailto:saleyn at gmail dot com"><tt>saleyn at gmail dot com</tt></a>).</p>
<p>This application implements a manager of OS processes.</p>

<p>It's designed to address the shortcomings of Erlang's
<code>os:cmd/1</code> and <code>erlang:open_port/2</code> that allow to execute external
OS processes.</p>

<h3><a name="Contents">Contents</a></h3>
<ol>
  <li><a href="#Download">Download</a></li>
  <li><a href="#Features">Features</a></li>
  <li><a href="#Supported_Platforms">Supported Platforms</a></li>
  <li><a href="#Architecture">Architecture</a></li>
  <li><a href="#Configuration_Options">Configuration Options</a></li>
  <li><a href="#Examples">Examples</a></li>
</ol>


<h3><a name="Download">Download</a></h3>

<ul>
<li>Project's repository: <a href="https://github.com/saleyn/erlexec" target="_top"><tt>https://github.com/saleyn/erlexec</tt></a></li>
<li>Git clone command: <code>git clone https://github.com/saleyn/erlexec.git</code></li>
</ul>

<h3><a name="Build">Build</a></h3>

<pre>make</pre>

<p>On Linux the <code>exec-port</code> process can be enabled to execute commands under
different effective users. In order to accomplish that, you need to set
Linux capabilities on <code>exec-port</code> using the following command:</p>

<pre>sudo setcap cap_setuid,cap_kill,cap_sys_nice+eip _build/default/lib/erlexec/priv/*/exec-port</pre>

<h3><a name="Features">Features</a></h3>

<ol>
<li>Starting, stopping OS commands and getting their OS process IDs.</li>
<li>Setting OS command working directory, environment, effective user,
    process priority.</li>
<li>Providing custom termination command for killing a process or relying
    on default SIGTERM/SIGKILL behavior.  Specifying custom timeout
    for SIGKILL after the termination command or SIGTERM was executed.</li>
<li>Terminating all processing beloging to a process group</li>
<li>Ability to link Erlang processes to OS processes (via intermediate
    Erlang Pids that are linked to an associated OS process).</li>
<li>Ability to monitor the termination of OS processes.</li>
<li>Ability to execute OS processes synchronously and asynchronously.</li>
<li>Proper cleanup of OS processes at port program termination time.</li>
<li>Communicating with an OS process via its STDIN.</li> 
<li>Redirecting STDOUT and STDERR of an OS process to a file, erlang process,
  or a custom function. When redirected to a file, the file can be
  open in append/truncate mode, and given creation access mask.</li>
<li>Running interactive processes with psudo-terminal pty support.</li>
</ol>

<h3><a name="Supported_Platforms">Supported Platforms</a></h3>

<p>Linux, Solaris, and MacOS X.</p>

<h3><a name="Architecture">Architecture</a></h3>
<pre>  *-------------------------*
  |   +----+ +----+ +----+  |
  |   |Pid1| |Pid2| |PidN|  |   Erlang light-weight Pids associated
  |   +----+ +----+ +----+  |   one-to-one with managed OsPids
  |         \   |   /       |
  |          \  |  /        |
  |           \ | / (links) |
  |         +------+        |
  |         | exec |        |   Exec application running in Erlang VM
  |         +------+        |
  | Erlang VM   |           |
  *-------------+-----------*
                |
          +-----------+
          | exec-port |         Port program (separate OS process)
          +-----------+
           /    |    \
 (optional stdin/stdout/stderr pipes)
         /      |      \
    +------+ +------+ +------+
    |OsPid1| |OsPid2| |OsPidN|  Managed Child OS processes
    +------+ +------+ +------+</pre>

<h3><a name="Configuration_Options">Configuration Options</a></h3>

<p>See description of types in <a href="exec.html#type-exec_options"><code>exec:exec_options()</code></a>.</p>

<p>The <code>exec-port</code> program requires the <code>SHELL</code> variable to be set. If you are
running Erlang inside a docker container, you might need to ensure that <code>SHELL</code>
is properly set prior to starting the emulator.</p>

<h3><a name="Examples">Examples</a></h3>

<h4><a name="Starting/stopping_an_OS_process">Starting/stopping an OS process</a></h4>
<pre>1&gt; exec:start([]).                                      % Start the port program.
{ok,&lt;0.32.0&gt;}
2&gt; {ok, _, I} = exec:run_link("sleep 1000", []).        % Run a shell command to sleep for 1000s.
{ok,&lt;0.34.0&gt;,23584}
3&gt; exec:stop(I).                                        % Kill the shell command.
ok                                                      % Note that this could also be accomplished
                                                        % by doing exec:stop(pid(0,34,0)).</pre>

<h4><a name="Running_exec-port_as_another_effective_user">Running exec-port as another effective user</a></h4>

<p>In order to be able to use this feature the current user must either have <code>sudo</code>
rights or the <code>exec-port</code> file must have the SUID bit set. If the effective user
doesn't have rights to access the <code>exec-port</code> program in the real user's directory,
then the <code>exec-port</code> can be copied to some shared location, which will be specified
at startup using <code>{portexe, "/path/to/exec-port"}</code>.</p>

<pre>$ cp $(find . -name exec-port) /tmp
$ chmod 755 /tmp/exec-port

$ whoami
serge

$ erl
1&gt; exec:start([{user, "wheel"}, {portexe, "/tmp/exec-port"}]).  % Start the port program as effective user "wheel".
{ok,&lt;0.32.0&gt;}

$ ps haxo user,comm | grep exec-port
wheel      exec-port</pre>

<h4><a name="Allowing_exec-port_to_run_commands_as_other_effective_users">Allowing exec-port to run commands as other effective users</a></h4>

<p>In order to be able to use this feature the current user must either have <code>sudo</code>
rights or the <code>exec-port</code> file must have the SUID bit set, and the <code>exec-port</code> file
must have the capabilities set as described in the "Build" section above.</p>

<p>The port program will initially be started as <code>root</code>, and then it will set the
<code>cap_setuid,cap_kill,cap_sys_nice</code> capabilities and switch the effective user to
<code>{user, User}</code>.  After that it'll allow to run child programs under effective
users listed in the <code>{limit_users, Users}</code> option.</p>

<pre>$ whoami
serge

$ erl
1&gt; Opts = [root, {user, "wheel"}, {limit_users, "alex","guest"}}],
2&gt; exec:start(Opts).                                    % Start the port program as effective user "wheel"
                                                        % and allow it to execute commands as "alex" or "guest".
{ok,&lt;0.32.0&gt;}
3&gt; exec:run("whoami", [sync, stdout, {user, "alex"}]).  % Command is executed under effective user "alex"
{ok,[{stdout,[&lt;&lt;"alex\n"&gt;&gt;]}]}

$ ps haxo user,comm | grep exec-port
wheel      exec-port</pre>

<h4><a name="Killing_an_OS_process">Killing an OS process</a></h4>

Note that killing a process can be accomplished by running kill(3) command
in an external shell, or by executing exec:kill/2.
<pre>1&gt; f(I), {ok, _, I} = exec:run_link("sleep 1000", []).
{ok,&lt;0.37.0&gt;,2350}
2&gt; exec:kill(I, 15).
ok
** exception error: {exit_status,15}                    % Our shell died because we linked to the
                                                        % killed shell process via exec:run_link/2.

3&gt; exec:status(15).                                     % Examine the exit status.
{signal,15,false}                                       % The program got SIGTERM signal and produced
                                                        % no core file.</pre>

<h4><a name="Using_a_custom_success_return_code">Using a custom success return code</a></h4>
<pre>1&gt; exec:start_link([]).
{ok,&lt;0.35.0&gt;}
2&gt; exec:run_link("sleep 1", [{success_exit_code, 0}, sync]).
{ok,[]}
3&gt; exec:run("sleep 1", [{success_exit_code, 1}, sync]).
{error,[{exit_status,1}]}                               % Note that the command returns exit code 1</pre>

<h4><a name="Redirecting_OS_process_stdout_to_a_file">Redirecting OS process stdout to a file</a></h4>
<pre>7&gt; f(I), {ok, _, I} = exec:run_link("for i in 1 2 3; do echo \"Test$i\"; done",
    [{stdout, "/tmp/output"}]).
8&gt; io:format("~s", [binary_to_list(element(2, file:read_file("/tmp/output")))]),
   file:delete("/tmp/output").
Test1
Test2
Test3
ok</pre>

<h4><a name="Redirecting_OS_process_stdout_to_screen,_an_Erlang_process_or_a_custom_function">Redirecting OS process stdout to screen, an Erlang process or a custom function</a></h4>
<pre>9&gt; exec:run("echo Test", [{stdout, print}]).
{ok,&lt;0.119.0&gt;,29651}
Got stdout from 29651: &lt;&lt;"Test\n"&gt;&gt;

10&gt; exec:run("for i in 1 2 3; do sleep 1; echo \"Iter$i\"; done",
            [{stdout, fun(S,OsPid,D) -&gt; io:format("Got ~w from ~w: ~p\n", [S,OsPid,D]) end}]).
{ok,&lt;0.121.0&gt;,29652}
Got stdout from 29652: &lt;&lt;"Iter1\n"&gt;&gt;
Got stdout from 29652: &lt;&lt;"Iter2\n"&gt;&gt;
Got stdout from 29652: &lt;&lt;"Iter3\n"&gt;&gt;

% Note that stdout/stderr options are equivanet to {stdout, self()}, {stderr, self()} 
11&gt; exec:run("echo Hello World!; echo ERR!! 1&gt;&amp;2", [stdout, stderr]).
{ok,&lt;0.244.0&gt;,18382}
12&gt; flush().
Shell got {stdout,18382,&lt;&lt;"Hello World!\n"&gt;&gt;}
Shell got {stderr,18382,&lt;&lt;"ERR!!\n"&gt;&gt;}
ok</pre>

<h4><a name="Appending_OS_process_stdout_to_a_file">Appending OS process stdout to a file</a></h4>
<pre>13&gt; exec:run("for i in 1 2 3; do echo TEST$i; done",
        [{stdout, "/tmp/out", [append, {mode, 8#600}]}, sync]),
    file:read_file("/tmp/out").
{ok,&lt;&lt;"TEST1\nTEST2\nTEST3\n"&gt;&gt;}
14&gt; exec:run("echo Test4; done", [{stdout, "/tmp/out", [append, {mode, 8#600}]}, sync]),
    file:read_file("/tmp/out").
{ok,&lt;&lt;"TEST1\nTEST2\nTEST3\nTest4\n"&gt;&gt;}
15&gt; file:delete("/tmp/out").</pre>

<h4><a name="Setting_up_a_monitor_for_the_OS_process">Setting up a monitor for the OS process</a></h4>
<pre>&gt; f(I), f(P), {ok, P, I} = exec:run("echo ok", [{stdout, self()}, monitor]).
{ok,&lt;0.263.0&gt;,18950}
16&gt; flush().                                                                  
Shell got {stdout,18950,&lt;&lt;"ok\n"&gt;&gt;}
Shell got {'DOWN',18950,process,&lt;0.263.0&gt;,normal}
ok</pre>

<h4><a name="Managing_an_externally_started_OS_process">Managing an externally started OS process</a></h4>
This command allows to instruct erlexec to begin monitoring given OS process
and notify Erlang when the process exits. It is also able to send signals to
the process and kill it.
<pre>% Start an externally managed OS process and retrieve its OS PID:
17&gt; spawn(fun() -&gt; os:cmd("echo $$ &gt; /tmp/pid; sleep 15") end).
&lt;0.330.0&gt;  
18&gt; f(P), P = list_to_integer(lists:reverse(tl(lists:reverse(binary_to_list(element(2,
file:read_file("/tmp/pid"))))))).
19355

% Manage the process and get notified by a monitor when it exits:
19&gt; exec:manage(P, [monitor]).
{ok,&lt;0.334.0&gt;,19355}

% Wait for monitor notification
20&gt; f(M), receive M -&gt; M end.
{'DOWN',19355,process,&lt;0.334.0&gt;,{exit_status,10}}
ok
21&gt; file:delete("/tmp/pid").
ok</pre>

<h4><a name="Specifying_custom_process_shutdown_delay_in_seconds">Specifying custom process shutdown delay in seconds</a></h4>
<pre>% Execute an OS process (script) that blocks SIGTERM with custom kill timeout, and monitor
22&gt; f(I), {ok, _, I} = exec:run("trap '' SIGTERM; sleep 30", [{kill_timeout, 3}, monitor]).
{ok,&lt;0.399.0&gt;,26347}
% Attempt to stop the OS process
23&gt; exec:stop(I).
ok
% Wait for its completion
24&gt; f(M), receive M -&gt; M after 10000 -&gt; timeout end.                                          
{'DOWN',26347,process,&lt;0.403.0&gt;,normal}</pre>

<h4><a name="Communicating_with_an_OS_process_via_STDIN">Communicating with an OS process via STDIN</a></h4>
<pre>% Execute an OS process (script) that reads STDIN and echoes it back to Erlang
25&gt; f(I), {ok, _, I} = exec:run("read x; echo \"Got: $x\"", [stdin, stdout, monitor]).
{ok,&lt;0.427.0&gt;,26431}
% Send the OS process some data via its stdin
26&gt; exec:send(I, &lt;&lt;"Test data\n"&gt;&gt;).                                                  
ok
% Get the response written to processes stdout
27&gt; f(M), receive M -&gt; M after 10000 -&gt; timeout end.
{stdout,26431,&lt;&lt;"Got: Test data\n"&gt;&gt;}
% Confirm that the process exited
28&gt; f(M), receive M -&gt; M after 10000 -&gt; timeout end.
{'DOWN',26431,process,&lt;0.427.0&gt;,normal}</pre>

<h4><a name="Communicating_with_an_OS_process_via_STDIN_and_sending_end-of-file">Communicating with an OS process via STDIN and sending end-of-file</a></h4>
<pre>2&gt; Watcher = spawn(fun F() -&gt; receive Msg -&gt; io:format("Got: ~p\n", [Msg]), F() end end).
&lt;0.112.0&gt;
3&gt; f(Pid), f(OsPid), {ok, Pid, OsPid} = exec:run("tac", [stdin, {stdout, Watcher}, {stderr, Watcher}]).
{ok,&lt;0.114.0&gt;,26143}
4&gt; exec:send(Pid, &lt;&lt;"foo\n"&gt;&gt;).
ok
5&gt; exec:send(Pid, &lt;&lt;"bar\n"&gt;&gt;).
ok
6&gt; exec:send(Pid, &lt;&lt;"baz\n"&gt;&gt;).
ok
7&gt; exec:send(Pid, eof).
ok
Got: {stdout,26143,&lt;&lt;"baz\nbar\nfoo\n"&gt;&gt;}</pre>

<h4><a name="Running_OS_commands_synchronously">Running OS commands synchronously</a></h4>
<pre>% Execute an shell script that blocks for 1 second and return its termination code
29&gt; exec:run("sleep 1; echo Test", [sync]).
% By default all I/O is redirected to /dev/null, so no output is captured
{ok,[]}

% 'stdout' option instructs the port program to capture stdout and return it to caller
30&gt; exec:run("sleep 1; echo Test", [stdout, sync]).
{ok,[{stdout, [&lt;&lt;"Test\n"&gt;&gt;]}]}

% Execute a non-existing command
31&gt; exec:run("echo1 Test", [sync, stdout, stderr]).   
{error,[{exit_status,32512},
        {stderr,[&lt;&lt;"/bin/bash: echo1: command not found\n"&gt;&gt;]}]}

% Capture stdout/stderr of the executed command
32&gt; exec:run("echo Test; echo Err 1&gt;&amp;2", [sync, stdout, stderr]).    
{ok,[{stdout,[&lt;&lt;"Test\n"&gt;&gt;]},{stderr,[&lt;&lt;"Err\n"&gt;&gt;]}]}

% Redirect stderr to stdout
33&gt; exec:run("echo Test 1&gt;&amp;2", [{stderr, stdout}, stdout, sync]).
{ok, [{stdout, [&lt;&lt;"Test\n"&gt;&gt;]}]}</pre>

<h4><a name="Running_OS_commands_with/without_shell">Running OS commands with/without shell</a></h4>
<pre>% Execute a command by an OS shell interpreter
34&gt; exec:run("/bin/echo ok", [sync, stdout]).
{ok, [{stdout, [&lt;&lt;"ok\n"&gt;&gt;]}]}

% Execute an executable without a shell
35&gt; exec:run(["/bin/echo", "ok"], [sync, stdout])).
{ok, [{stdout, [&lt;&lt;"ok\n"&gt;&gt;]}]}

% Execute a shell with custom options
36&gt; exec:run(["/bin/bash", "-c", "echo ok"], [sync, stdout])).
{ok, [{stdout, [&lt;&lt;"ok\n"&gt;&gt;]}]}</pre>

<h4><a name="Running_OS_commands_with_pseudo_terminal_(pty)">Running OS commands with pseudo terminal (pty)</a></h4>
<pre>% Execute a command without a pty
37&gt; exec:run("echo hello", [sync, stdout]).
{ok, [{stdout,[&lt;&lt;"hello\n"&gt;&gt;]}]}

% Execute a command with a pty
38&gt; exec:run("echo hello", [sync, stdout, pty]).
{ok,[{stdout,[&lt;&lt;"hello"&gt;&gt;,&lt;&lt;"\r\n"&gt;&gt;]}]}</pre>
 
<h4><a name="Kill_a_process_group_at_process_exit">Kill a process group at process exit</a></h4>
<pre>% In the following scenario the process P0 will create a new process group
% equal to the OS pid of that process (value = GID). The next two commands
% are assigned to the same process group GID. As soon as the P0 process exits
% P1 and P2 will also get terminated by signal 15 (SIGTERM):
39&gt; {ok, P0, GID} = exec:run("sleep 10",  [{group, 0},   kill_group]).
{ok,&lt;0.37.0&gt;,25306}
40&gt; {ok, P1,   _} = exec:run("sleep 15",  [{group, GID}, monitor]).
{ok,&lt;0.39.0&gt;,25307}
41&gt; {ok, P2,   _} = exec:run("sleep 15",  [{group, GID}, monitor]).
{ok,&lt;0.41.0&gt;,25308}
42&gt; flush().
Shell got {'DOWN',25307,process,&lt;0.39.0&gt;,{exit_status,15}}
Shell got {'DOWN',25308,process,&lt;0.41.0&gt;,{exit_status,15}}
ok</pre>
<hr>
<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Oct 25 2016, 20:09:31.</i></p>
</body>
</html>
